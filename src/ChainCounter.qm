<?xml version="1.0" encoding="UTF-8"?>
<model version="5.2.5" links="0">
 <framework name="qpcpp"/>
 <package name="Events" stereotype="0x01"/>
 <package name="AOs" stereotype="0x02">
  <class name="MotorController" superclass="qpcpp::QActive">
   <attribute name="inst" type="MotorController" visibility="0x00" properties="0x01"/>
   <operation name="MotorController" type="" visibility="0x00" properties="0x00">
    <code>  : QActive(Q_STATE_CAST(&amp;MotorController::initial))</code>
   </operation>
   <statechart properties="0x00">
    <initial target="../1">
     <initial_glyph conn="18,8,5,0,12,7">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="stopped">
     <entry brief="Stop motor">BSP::motorStop();</entry>
     <tran trig="UP_PRESSED" target="../../2">
      <tran_glyph conn="35,18,1,0,25,2">
       <action box="0,-2,12,2"/>
      </tran_glyph>
     </tran>
     <tran trig="DOWN_PRESSED" target="../../3">
      <tran_glyph conn="18,22,3,3,-10,20,19">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="18,15,17,12">
      <entry box="1,2,12,3"/>
     </state_glyph>
    </state>
    <state name="going_up">
     <entry brief="Activate motor up">BSP::motorUp();</entry>
     <tran trig="UP_RELEASED" target="../../1">
      <tran_glyph conn="55,27,3,1,-18,-6,-2">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="55,20,15,12">
      <entry box="1,2,14,3"/>
     </state_glyph>
    </state>
    <state name="going_down">
     <entry brief="Activate motor down">BSP::motorDown();</entry>
     <tran trig="DOWN_RELEASED" target="../../1">
      <tran_glyph conn="27,39,3,3,-14,-15,5">
       <action box="0,-2,16,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="27,31,21,13">
      <entry box="1,2,17,2"/>
     </state_glyph>
    </state>
    <state_diagram size="80,50"/>
   </statechart>
  </class>
  <attribute name="AO_MotorController" type="QP::QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;MotorController::inst; // &quot;opaque&quot; AO pointer</code>
  </attribute>
  <class name="GypsyMonitor" superclass="qpcpp::QActive">
   <documentation>Keeps track of the  Gypsy movements based on signals received from the  three input lines

    DOWN_SENSE   -- Monitoring the voltage on the DOWN input to the reversing relay (RISING/FALLING)
    UP_SENSE     -- Monitoring the voltage on the UP input to the reversing relay (RISING/FALLING)
    GYPSY_PULSE  -- generated by the Reed Switch under the gypsy magnet 

</documentation>
   <attribute name="inst" type="GypsyMonitor" visibility="0x00" properties="0x01"/>
   <attribute name="count" type="std::int32_t" visibility="0x02" properties="0x00">
    <documentation>The total pulses counted (increments: down = +1, up = -1)</documentation>
   </attribute>
   <attribute name="increment" type="std::int8_t" visibility="0x02" properties="0x00">
    <documentation>The value by which the count will change at each GYPSY_PULSE</documentation>
   </attribute>
   <operation name="GypsyMonitor" type="" visibility="0x00" properties="0x00">
    <code>  : QActive(Q_STATE_CAST(&amp;GypsyMonitor::initial))</code>
   </operation>
   <statechart properties="0x00">
    <initial target="../1">
     <action brief="initialise count">count = 0; // initialise the counter to zero (should be value in EPROM)</action>
     <initial_glyph conn="8,4,5,0,11,4">
      <action box="-3,1,13,3"/>
     </initial_glyph>
    </initial>
    <state name="stopped">
     <tran trig="DOWN_SENSE_APPLIED" target="../../2/2/2">
      <tran_glyph conn="23,23,1,3,30">
       <action box="1,1,21,3"/>
      </tran_glyph>
     </tran>
     <tran trig="UP_SENSE_APPLIED" target="../../2/2/1">
      <tran_glyph conn="19,27,2,3,5,34">
       <action box="1,1,20,2"/>
      </tran_glyph>
     </tran>
     <tran trig="GYPSY_PULSE" target="../../2/1">
      <action brief="in freefall, start counting">count += increment;</action>
      <tran_glyph conn="17,27,2,3,21,34">
       <action box="1,15,19,5"/>
      </tran_glyph>
     </tran>
     <state name="unclutched">
      <documentation>The gypsy clutch has been released and the drive motor  is active (no GYPSY_PULSE signals are being received</documentation>
      <state_glyph node="5,14,14,8"/>
     </state>
     <state_glyph node="2,8,21,19"/>
    </state>
    <state name="moving">
     <tran trig="GYPSY_PULSE">
      <action brief="update counter">count += increment;</action>
      <tran_glyph conn="46,56,3,-1,25">
       <action box="0,-2,16,5"/>
      </tran_glyph>
     </tran>
     <state name="freefall">
      <documentation>GYPSY_PULSEs are being recieved with no motor input -- must be freefall</documentation>
      <entry brief="set direction to +1">increment = 1;</entry>
      <state_glyph node="51,43,20,9">
       <entry box="1,2,17,4"/>
      </state_glyph>
     </state>
     <state name="driven">
      <tran trig="PULSE_TIMEOUT" target="../../../1/3">
       <tran_glyph conn="48,21,3,1,-27,-3,-2">
        <action box="-22,-3,17,2"/>
       </tran_glyph>
      </tran>
      <state name="raising">
       <documentation>The anchor is being raised by the motor</documentation>
       <entry brief="set direction to -1">increment = -1;</entry>
       <tran trig="DOWN_SENSE_APPLIED" target="../../../../3">
        <tran_glyph conn="71,32,1,3,19,-6,7">
         <action box="0,-2,21,2"/>
        </tran_glyph>
       </tran>
       <tran trig="UP_SENSE_REMOVED" target="../../3">
        <tran_glyph conn="71,29,1,1,3,-15,-6">
         <action box="-3,-18,18,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="53,27,18,8">
        <entry box="1,2,16,3"/>
       </state_glyph>
      </state>
      <state name="lowering">
       <documentation>The Anchor is being lowered via motor drive</documentation>
       <entry brief="set direction to +1">increment = 1;</entry>
       <tran trig="UP_SENSE_APPLIED" target="../../../../3">
        <tran_glyph conn="71,22,1,3,26">
         <action box="9,-3,15,4"/>
        </tran_glyph>
       </tran>
       <tran trig="DOWN_SENSE_REMOVED" target="../../3">
        <tran_glyph conn="53,20,3,3,-1,-6,2">
         <action box="-19,-5,18,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="53,17,18,8">
        <entry box="1,2,17,3"/>
       </state_glyph>
      </state>
      <state name="idling">
       <documentation>The motor has been driving the gypsy but the drive signal has been removed
The motor is now coming to a stop  however additional GYPSY_PULSEs may still be received</documentation>
       <entry brief="Arm Idle Timer">// Arm idle timer to allow windlass motor to run down to a stop</entry>
       <tran trig="IDLE_TIMEOUT" target="../../../../1">
        <tran_glyph conn="54,13,3,1,-23,2,-8">
         <action box="-21,-3,13,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="54,9,14,7">
        <entry box="1,2,13,2"/>
       </state_glyph>
      </state>
      <state_glyph node="48,6,27,33"/>
     </state>
     <state_glyph node="46,3,33,61"/>
    </state>
    <state name="opposed">
     <documentation>Error condition -- both reversing relay inputs (UP and DOWN)  are active at the  same time</documentation>
     <tran trig="RESET" target="../../1">
      <tran_glyph conn="108,30,2,2,40,-95,-43">
       <action box="-8,3,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="97,14,19,16"/>
    </state>
    <state_diagram size="117,77"/>
   </statechart>
  </class>
 </package>
 <directory name=".">
  <file name="bsp.hpp">
   <text>#ifndef BSP_HPP
#define BSP_HPP

class BSP {
public:
    enum { TICKS_PER_SEC = CONFIG_FREERTOS_HZ} ;
    static void init(void);
   // static void displayPaused(uint8_t const paused);  // from dpp app
   // static void displayPhilStat(uint8_t const n, char_t const *stat); // from dpp app
   // static void terminate(int16_t const result);  // from dpp app

    static void randomSeed(uint32_t const seed); // random seed
    static uint32_t random(void);                // pseudo-random generator
   // static QP::QTimeEvtCtr think_rnd_time();  // from dpp app
   // static QP::QTimeEvtCtr eat_rnd_time();  // from dpp app

    // declare helper functions
    static void motorUp(void);
    static void motorDown(void);
    static void motorStop(void);
};

#endif // BSP_HPP</text>
  </file>
  <file name="bsp.cpp">
   <text>#include &quot;qpcpp.hpp&quot;   // QP-C++ framework
#include &quot;chainCounter.hpp&quot;     // DPP application
#include &quot;bsp.hpp&quot;     // Board Support Package
#include &lt;Arduino.h&gt;
#include &quot;esp_freertos_hooks.h&quot;
/* from dpp app
#ifndef LED_BUILTIN  //If current ESP32 board does not define LED_BUILTIN
static constexpr unsigned LED_BUILTIN=13U; 
#endif
*/

// Define hardware pins for this application

static constexpr unsigned MOTOR_UP_PIN = 15U;     // HIGH = motor running, LOW motor off
static constexpr unsigned MOTOR_DOWN_PIN = 12U;   // HIGH = motor running, LOW motor off
static constexpr unsigned UP_BUTTON_PIN = 23U; 
static constexpr unsigned DOWN_BUTTON_PIN = 32U; 
static constexpr unsigned BUTTON_BOUNCE_SUPPRESS_MS = 5;


using namespace QP;


//----------------------------------------------------------------------------
// ISRs

struct Button {
    const uint8_t PIN;
    bool pressed;
    unsigned long last_interrupt_ms;
};

static QP::QSpyId const l_ISR_ID = { 0U }; // QSpy source ID

Button upButton = {UP_BUTTON_PIN, false, 0U};
Button downButton = {DOWN_BUTTON_PIN, false, 0U};

void IRAM_ATTR UP_BUTTON_ISR(void){
    unsigned long now_ms = millis();

    Serial.println(&quot;In UP button ISR&quot;);
    if  ((now_ms - upButton.last_interrupt_ms) &gt;  BUTTON_BOUNCE_SUPPRESS_MS) {
        // not a bounce
        upButton.pressed = ! upButton.pressed;
        upButton.last_interrupt_ms = now_ms;

        // publish event

        static QEvt const myEvt = { upButton.pressed? UP_PRESSED_SIG : UP_RELEASED_SIG, 0U, 0U};
        QF::PUBLISH(&amp;myEvt, &amp;l_ISR_ID);
    } else {
        
        // key bounce, ignore
    }
}

void IRAM_ATTR DOWN_BUTTON_ISR(void){
    unsigned long now_ms = millis();

    Serial.println(&quot;In DOWN button ISR&quot;);
    if  ((now_ms - downButton.last_interrupt_ms) &gt;  BUTTON_BOUNCE_SUPPRESS_MS) {
        // not a bounce
        downButton.pressed = ! downButton.pressed;
        downButton.last_interrupt_ms = now_ms;

        // publish event

        static QEvt const myEvt = { downButton.pressed? DOWN_PRESSED_SIG : DOWN_RELEASED_SIG, 0U, 0U};
        QF::PUBLISH(&amp;myEvt, &amp;l_ISR_ID);
    } else {
        
        // key bounce, ignore
    }
}



//............................................................................
// QS facilities

// un-comment if QS instrumentation needed
#define QS_ON

enum AppRecords { // application-specific QS trace records
    MOTOR_STAT = QP::QS_USER,
};

static QP::QSpyId const l_TIMER_ID = { 0U }; // QSpy source ID

//----------------------------------------------------------------------------
// BSP functions

static void tickHook_ESP32(void); /*Tick hook for QP */

static void tickHook_ESP32(void)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    /* process time events for rate 0 */
    //QF::TICK_FROM_ISR(&amp;xHigherPriorityTaskWoken, &amp;l_TIMER_ID);
    QTimeEvt::tickFromISR_(0U,&amp;xHigherPriorityTaskWoken, &amp;l_TIMER_ID);
    /* notify FreeRTOS to perform context switch from ISR, if needed */
    if(xHigherPriorityTaskWoken) {
        portYIELD_FROM_ISR();
    }
#ifndef QS_ON

/* from dpp app
    // Listen for commands coming from the host (via the QSpy app)
    if (Serial.available() &gt; 0) {
        switch (Serial.read()) { // read the incoming byte
            case 'p':
            case 'P':
                static QEvt const pauseEvt = { PAUSE_SIG, 0U, 0U};
                QF::PUBLISH(&amp;pauseEvt, &amp;l_TIMER_ID);
                break;
            case 's':
            case 'S':
                static QEvt const serveEvt = { SERVE_SIG, 0U, 0U};
                QF::PUBLISH(&amp;serveEvt, &amp;l_TIMER_ID);
                break;
        }
    }
*/
#endif
}

void BSP::init(void) {
    // initialize the hardware used in this sketch...
    // NOTE: interrupts are configured and started later in QF::onStartup()

    // pinMode(LED_BUILTIN, OUTPUT); // from dpp app

    // setup motor control pin, and stop the motor

    
    Serial.println(&quot;Setting PIN modes&quot;);
    pinMode(MOTOR_UP_PIN, OUTPUT);
    pinMode(MOTOR_DOWN_PIN, OUTPUT);
    motorStop();

    pinMode(UP_BUTTON_PIN, INPUT);
    pinMode(DOWN_BUTTON_PIN, INPUT);


    randomSeed(1234); // seed the Random Number Generator
    Serial.begin(115200); // set the highest stanard baud rate of 115200 bps
    QS_INIT(nullptr);  // what is this ??
#ifdef QS_ON
    // output QS dictionaries to QSpy running on the host
    QS_OBJ_DICTIONARY(&amp;l_TIMER_ID);
    QS_USR_DICTIONARY(MOTOR_STAT);

    // setup the QS filters...
    QS_GLB_FILTER(QP::QS_SM_RECORDS); // state machine records
    QS_GLB_FILTER(QP::QS_AO_RECORDS); // active object records
    QS_GLB_FILTER(QP::QS_UA_RECORDS); // all user records
#else
    Serial.print(&quot;QP-C++: &quot;);
    Serial.print(QP_VERSION_STR);
    Serial.println(&quot;&quot;);
#endif
}
//............................................................................
/*  from DPP app 
// generate a log record reporting the status of an AO instance
// in this case, one of the dining philosphers

void BSP::displayPhilStat(uint8_t n, char_t const *stat) {
#ifdef QS_ON
    QS_BEGIN_ID(PHILO_STAT, AO_Philo[n]-&gt;m_prio) // app-specific record begin
        QS_U8(1, n);  // Philo number
        QS_STR(stat); // Philo status
    QS_END()
#else
    Serial.print(&quot;Philosopher &quot;);
    Serial.write(48+n);
    Serial.print(&quot; &quot;);
    Serial.println(stat);
#endif
}
*/
/*
//............................................................................
void BSP::displayPaused(uint8_t paused) {
    char const *msg = paused ? &quot;Paused ON&quot; : &quot;Paused OFF&quot;;
#ifndef QS_ON
    Serial.println(msg);
#endif
}
*/

//............................................................................
void BSP::motorUp(void) {
    digitalWrite(MOTOR_UP_PIN, HIGH);
}

//............................................................................
void BSP::motorDown(void) {
    digitalWrite(MOTOR_DOWN_PIN, HIGH);
}

//............................................................................
void BSP::motorStop(void) {
    digitalWrite(MOTOR_UP_PIN, LOW);
    digitalWrite(MOTOR_DOWN_PIN, LOW);
}

//............................................................................
static uint32_t l_rnd; // random seed

void BSP::randomSeed(uint32_t seed) {
    l_rnd = seed;
}
//............................................................................
uint32_t BSP::random(void) { // a very cheap pseudo-random-number generator
    // &quot;Super-Duper&quot; Linear Congruential Generator (LCG)
    // LCG(2^32, 3*7*11*13*23, 0, seed)
    //
    uint32_t rnd = l_rnd * (3U*7U*11U*13U*23U);
    l_rnd = rnd; // set for the next time
    return (rnd &gt;&gt; 8);
}

//............................................................................
void QSpy_Task(void *) {
  while(1)
  {
    // transmit QS outgoing data (QS-TX)
    uint16_t len = Serial.availableForWrite();
    if (len &gt; 0U) { // any space available in the output buffer?
        uint8_t const *buf = QS::getBlock(&amp;len);
        if (buf) {
            Serial.write(buf, len); // asynchronous and non-blocking
        }
    }

    // receive QS incoming data (QS-RX)
    len = Serial.available();
    if (len &gt; 0U) {
        do {
            QP::QS::rxPut(Serial.read());
        } while (--len &gt; 0U);
        QS::rxParse();
    }
    delay(100);  // why delay?
  };
}

void QF::onStartup(void) {
    esp_register_freertos_tick_hook_for_cpu(tickHook_ESP32, QP_CPU_NUM);

    // register interrupts

    
    Serial.println(&quot;Attaching ISRs&quot;);

    attachInterrupt(UP_BUTTON_PIN, UP_BUTTON_ISR, CHANGE);
    attachInterrupt(DOWN_BUTTON_PIN, DOWN_BUTTON_ISR, CHANGE); 

#ifdef QS_ON
    xTaskCreatePinnedToCore(
                    QSpy_Task,   /* Function to implement the task */
                    &quot;QSPY&quot;, /* Name of the task */
                    10000,      /* Stack size in words */
                    NULL,       /* Task input parameter */
                    configMAX_PRIORITIES-1,          /* Priority of the task */
                    NULL,       /* Task handle. */
                    QP_CPU_NUM);  /* Core where the task should run */
#endif
}
//............................................................................

//............................................................................
extern &quot;C&quot; Q_NORETURN Q_onAssert(char const * const module, int location) {
    //
    // NOTE: add here your application-specific error handling
    //
    (void)module;
    (void)location;
    Serial.print(&quot;QP Assert module:&quot;);
    Serial.print(module);
    Serial.print(&quot;,&quot;);
    Serial.println(location);
    QF_INT_DISABLE(); // disable all interrupts
    for (;;) { // sit in an endless loop for now
    }
}

//----------------------------------------------------------------------------
// QS callbacks...
//............................................................................
bool QP::QS::onStartup(void const * arg) {
    static uint8_t qsTxBuf[1024]; // buffer for QS transmit channel (QS-TX)
    static uint8_t qsRxBuf[128];  // buffer for QS receive channel (QS-RX)
    initBuf  (qsTxBuf, sizeof(qsTxBuf));
    rxInitBuf(qsRxBuf, sizeof(qsRxBuf));
    return true; // return success
}
//............................................................................
void QP::QS::onCommand(uint8_t cmdId, uint32_t param1,
                       uint32_t param2, uint32_t param3)
{
}
//............................................................................
void QP::QS::onCleanup(void) {
}
//............................................................................
QP::QSTimeCtr QP::QS::onGetTime(void) {
#ifdef QS_ON
    return millis();
#else
    return 0;
#endif

}
//............................................................................
void QP::QS::onFlush(void) {
#ifdef QS_ON
    uint16_t len = 0xFFFFU; // big number to get as many bytes as available
    uint8_t const *buf = QS::getBlock(&amp;len); // get continguous block of data
    while (buf != nullptr) { // data available?
        Serial.write(buf, len); // might poll until all bytes fit
        len = 0xFFFFU; // big number to get as many bytes as available
        buf = QS::getBlock(&amp;len); // try to get more data
    }
    Serial.flush(); // wait for the transmission of outgoing data to complete
#endif // QS_ON
}
//............................................................................
void QP::QS::onReset(void) {
    esp_restart(); 
}
</text>
  </file>
  <file name="chainCounter.hpp">
   <text>#ifndef CHAINCOUNTER_HPP
#define CHAINCOUNTER_HPP

enum Signals {

/* from DDP app
    EAT_SIG = QP::Q_USER_SIG, // published by Table to let a Philosopher eat
    DONE_SIG,       // published by Philosopher when done eating
    PAUSE_SIG,      // published by BSP to pause the application
    SERVE_SIG,      // published by BSP to serve re-start serving forks
    TEST_SIG,       // published by BSP to test the application
    MAX_PUB_SIG,    // the last published signal

    TIMEOUT_SIG,    // timeout used by Time Events
    HUNGRY_SIG,     // posted direclty to Table from hungry Philo
    MAX_SIG         // the last signal
*/
    //UP Button signals
    UP_PRESSED_SIG = QP::Q_USER_SIG,    // Published by button ISR
    UP_RELEASED_SIG,                     // Published by button ISR
    // DOWN button signals
    DOWN_PRESSED_SIG,                   // Published by button ISR
    DOWN_RELEASED_SIG,                  // Published by button ISR
    // Reversing relay signals
    UP_SENSE_APPLIED_SIG,
    UP_SENSE_REMOVED_SIG,
    DOWN_SENSE_APPLIED_SIG,
    DOWN_SENSE_REMOVED_SIG,
    // Gypsy reed switch signal
    GYPSY_PULSE_SIG
    MAX_PUB_SIG,
    IDLE_TIMEOUT_SIG,  // POSTED by timer at end of windless motor rundown period
    PULSE_TIMEOUT_SIG, // POSTED by timer if  the motor is driving the windlass but no pulses are being received
                        // that is, the Gypsy must be declutched with the windlass acting as a winch
    MAX_SIG        // the last signal
};

// generate declarations all event classes
$declare${Events}

/* from  DPP app
// number of philosophers
enum { N_PHILO = 5 };


// generate declarations of all opaque pointers...
$declare(AOs::AO_Philo[N_PHILO])
$declare(AOs::AO_Table)
*/

// generate declarations of all opaque pointers...
$declare(AOs::AO_MotorController)

#endif // CHAINCOUNTER_HPP
</text>
  </file>
  <file name="main.cpp">
   <text>#include &quot;qpcpp.hpp&quot;  // QP-C++ framework
#include &quot;chainCounter.hpp&quot;    // Chain Counter application
#include &quot;bsp.hpp&quot;    // Board Support Package

using namespace QP;
static constexpr unsigned stack_size = 1000;

Q_DEFINE_THIS_FILE

//............................................................................
void setup() {
    QF::init(); // initialize the framework
    BSP::init(); // initialize the Board Support Package

    // init publish-subscribe
    static QSubscrList subscrSto[MAX_PUB_SIG];
    QF::psInit(subscrSto, Q_DIM(subscrSto));

    // initialize event pools...
/*
    static QF_MPOOL_EL(TableEvt) smlPoolSto[2*N_PHILO];
    QF::poolInit(smlPoolSto,
                 sizeof(smlPoolSto), sizeof(smlPoolSto[0]));
*/
    // start all active objects...
/*
    // start Philos
    static QP::QEvt const *philoQueueSto[10][N_PHILO];
    for (uint8_t n = 0U; n &lt; N_PHILO; ++n) {
        AO_Philo[n]-&gt;start((uint_fast8_t)(n + 1U), // priority
            philoQueueSto[n], Q_DIM(philoQueueSto[n]),
            (void *)0, stack_size);
    }
    // start Table
    static QP::QEvt const *tableQueueSto[N_PHILO];
    AO_Table-&gt;start((uint_fast8_t)(N_PHILO + 1U), // priority
        tableQueueSto, Q_DIM(tableQueueSto),
        (void *)0, stack_size);
*/
   // start the Motor Controller
    static QP::QEvt const *motorControllerQueueSto[2U];
    AO_MotorController-&gt;start((uint_fast8_t)(2U + 1U), // priority
        motorControllerQueueSto, Q_DIM(motorControllerQueueSto),
        (void *)0, stack_size);
    QF::run(); // run the QF/C++ framework
}

//............................................................................
void loop() {
}</text>
  </file>
  <file name="motorController.cpp">
   <text>#include &quot;qpcpp.hpp&quot;   // QP-C++ framework
#include &quot;chainCounter.hpp&quot;     // DPP application
#include &quot;bsp.hpp&quot;     // Board Support Package

Q_DEFINE_THIS_FILE

// generate declaration of the active object ---------------------------------
$declare${AOs::MotorController}

// generate definition of the opaque pointer to the AO -----------------------
$define${AOs::AO_MotorController}


/*
// helper function to provide the RIGHT neighbour of a Philo[n]
inline uint8_t RIGHT(uint8_t const n) {
    return static_cast&lt;uint8_t&gt;((n + (N_PHILO - 1U)) % N_PHILO);
}

// helper function to provide the LEFT neighbour of a Philo[n]
inline uint8_t LEFT(uint8_t const n) {
    return static_cast&lt;uint8_t&gt;((n + 1U) % N_PHILO);
}

static uint8_t const FREE = static_cast&lt;uint8_t&gt;(0);
static uint8_t const USED = static_cast&lt;uint8_t&gt;(1);

static char const * const THINKING = &quot;thinking&quot;;
static char const * const HUNGRY   = &quot;hungry  &quot;;
static char const * const EATING   = &quot;eating  &quot;;
*/

// generate definition of the AO ---------------------------------------------
$define${AOs::MotorController}

</text>
  </file>
 </directory>
</model>
